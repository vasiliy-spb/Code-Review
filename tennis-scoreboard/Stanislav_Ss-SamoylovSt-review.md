# Review на реализацию от [@Stanislav_Ss](https://github.com/SamoylovSt/tennis-match-scoreboard) проекта [Табло теннисного матча](https://zhukovsd.github.io/java-backend-learning-course/projects/tennis-scoreboard/)

```text
Знаком ❗️ помечены критические замечания, а также места нарушения ТЗ.
Если ❗️ стоит перед заголовком, значит он относится ко всем пунктам этого раздела.
```

## ❗️Функциональные ошибки

1. Выигрыш гейма происходит при счёте 40:x
2. Когда игрок выиграл 6 геймов надо ещё раз нажать на 'Score', чтобы засчитался выигрыш сета. Также при этом не
   обнуляется счёт у соперника.
3. При счёте 6:6 по геймам начинается тай-брейк, но сбрасываются очки геймов
4. Если попробовать отфильтровать матчи по имени несуществующего игрока, то на странице с ошибкой будет
сообщение `java.lang.NullPointerException: Cannot invoke "entity.Player.getId()" because the return value of "dao.PlayerDao.findPlayerByName(dto.PlayerNameDto)" is null`.
Вместо этого было бы логично показать пустой список матчей. Или в крайнем случае какое-то содержательное для простого
пользователя сообщение об ошибке.

## JSP

1. ❗️jsp страницы должны быть в папке `WEB-INF`, чтобы к ним не было прямого доступа. Файлы из этой папки нельзя запросить
   напрямую, только через сервлеты. Тогда и в адресной строке в конце не будет отображаться `*.jsp`
2. Не везде в файлах .jsp есть [JSTL declaration](https://java-online.ru/jsp-jstl.xhtml). Это строчка
   вида `<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>` в начале файла.

   Без JSTL declaration страницы могут работать в некоторых окружениях, но это ненадёжно и не
   соответствует [спецификации](https://github.com/jakartaee/pages/blob/main/spec/src/main/asciidoc/server-pages-spec-body.adoc#1102-the-taglib-directive).
3. В файле `new-match.jsp` отсутствует тег `<html>`. Технически без него страница будет работать, но это тоже нарушение
   стандарта и где-то может вызывать ошибки отображения страницы.
4. Вместо абсолютных путей лучше использовать относительные — `${pageContext.request.contextPath}/page-name`. Благодаря
   этому все ссылки будут работать независимо от того, по какому адресу будет развёрнуто приложение (в корне контекста
   или в подпапке).

#### То есть например в match-score.jsp

- строка 28. `<a class="nav-link" href="/matches">Matches</a>` -> `<a class="nav-link" href="${pageContext.request.contextPath}/matches">Matches</a>`
- строка 56. `<form action="/match-score" method="post">` -> `<form action="${pageContext.request.contextPath}/match-score" method="post">`

```
В Idea есть возможность изменить сразу все вхождения подстроки в файле. Для этого можно в jsp файле:
- выделить всё содержимое тега <body> кроме <footer> (или другой нужный фрагмент)
- нажать cmd + R, 
- далее в верхней строке указать 'href="', 
- в нижней 'href="${pageContext.request.contextPath}' 
- и нажать 'Replace All'

Аналогично для 'action="'.
```

5. То же относится к путям к /js и /css
6. Можно переименовать `index.html` в `index.jsp`, чтобы иметь возможность использовать JSTL и единообразно
   применять `${pageContext.request.contextPath}` во всех страницах.
7. Все стили из jsp страниц можно вынести в css файл.
8. В `style.css` можно безболезненно заменить классы .player1 и .player2 на просто .player. Хотя так
9. На странице `winner.jsp`, кажется условие:

```html
<c:when test="${not empty winnerName}">
```

всегда true.

А также не существует ситуации, когда срабатывает блок:

```html
<c:otherwise>
    <div class="winner-name">${loserName}</div>
    <div class="congratulations">Defeat</div>
</c:otherwise>
```

Можно просто всегда показывать имя победителя

10. В пагинации на странице `matches.jsp` отображаются все страницы, что будет плохо выглядеть при большом количестве
    страниц. Можно сделать отображение текущей и +- 2 страниц вокруг неё.

11. В строке 97 в файле `matches.jsp` не закрыт тэг `</div>`

## DTO

- все классы dto могут быть record. Они неизменяемые по умолчанию, с
  автоматическими `equals()`, `hashCode()`, `toString()`, без явного указания модификаторов доступа.
  вместо:

```java

@Data
public class MatchListDto {
    private String playerOneName;
    private String playerTwoName;
    private String winnerName;
}
```

будет:

```java
public record MatchListDto(
    String playerOneName,
    String playerTwoName,
    String winnerName
) {
}
```

### MatchBoardDto

- Избыточный геттер для поля `isFinish` — Lombok @Data уже генерирует isFinish()

```java
public boolean isFinish(){
    return isFinish;
}
```

Посмотреть, как выглядит класс со сгенерированным кодом можно в `build/classes/java/main/dto/MatchBoardDto.class` после
сборки проекта.

- переменная `int tiebreakOnOff` используется как флаг, а значит лучше сделать её boolean
- код будет понятнее, если переменную `int tiebreakOnOff` переименовать, например в `boolean isTiebreak` или
  просто `boolean tiebreak`
- имена `PlayerScoreDto playerScoreDto1` и  `PlayerScoreDto playerScoreDto2` тоже можно упростить до `playerScore1`
  и `playerScore2`. А ещё лучше не использовать цифры в именах переменных (чуть подробнее об этом будет сказано ниже).
- в название класса не нужно слово `Board`. Можно переименовать в `MatchScoreDto`.

### MatchListDto

- не нужно добавлять слово `List` в название класса только потому, что объекты этого класса используются в списках.
  Можно сократить до `MatchDto`.

### PlayerNameDto

- в этом dto только одно поле — можно напрямую использовать String, там где сейчас используется PlayerNameDto

### PlayerScoreDto

- ❗️DTO не должен содержать логику конвертации
- всю пользу метода

```java
public PlayerNameDto convertToPlayerNameDto(PlayerScoreDto player) {
    PlayerNameDto playerNameDto=new PlayerNameDto();
    playerNameDto.setName(player.getName());
    return playerNameDto;
}
```

можно получить вызовом `player.getName()` в нужном месте.

- если метод конвертации всё же останется, его стоит перенести в сервис или маппер

### winnerDto

- нигде не используется
- находится в пакете `util`, возможно поэтому и потерялось. Стоит или удалить или перенести (если будет использоваться)
  в пакет к остальным DTO
- Исправить опечатку в названии класса (должно быть с заглавной буквы)
- поля `winnerName` и `loserName` объявлены без модификатора доступа. Это означает, что они имеют модификатор доступа по
  умолчанию (package-private) и видны для всего пакета `util`. Пока этот класс не стал record, поля должны быть private
  c доступом через геттеры (геттеры генерируются Lombok @Data)

## Filter

- Поправить адрес jsp страницы в методе `redirect(...)` (после перемещения их в WEB-INF).
- можно в ExceptionFilter наследоваться от HttpFilter, тогда в методе `doFilter(...)` будет не нужно приведение
  параметров к нужному типу:

```java
HttpServletRequest req=(HttpServletRequest)request;
HttpServletResponse resp=(HttpServletResponse)response;
```

- названия методов принято делать глаголами: `exceptionHandle` — существительное, `handleException` — глагол.

## Entity

- `@EqualsAndHashCode` (которая входит в `@Data`) обычно не используют в jpa сущностях. Конкретно здесь проблем быть не
  должно, но использование этих аннотаций не является хорошей практикой.

### Player

- ❗️отсутствует индекс для БД на поле `name`

<details>
<summary>
Например, так (спойлеры):
</summary>

```java
@Column(name = "name", nullable = false, length = 30, unique = true)
private String name;
```

или так:

```java
@Table(name = "players", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"name"})
})
public class Player
```

или так:

```java
@Table(name = "players", indexes = {
        @Index(name = "uq_players_name", columnList = "name", unique = true)
})
public class Player
```

</details>

- `@Column(name = "name")` можно опустить, если имя поля совпадает с именем колонки

### Match

- поле `Integer id` без модификатора private
- поля игроков стоит сделать обязательными

<details>
<summary>
Например, так (спойлеры):
</summary>

```java
@ManyToOne(optional = false)
@JoinColumn(name = "player1", nullable = false)
private Player player1;
```

</details>

## Dao

- ❗️новый EntityManager создаётся и закрывается в каждом методе, что может привести к тому, что несколько операций в
  рамках одного запроса будут использовать разные EntityManager. Это будет неэффективно. Лучше использовать один
  EntityManager на весь HTTP-запрос (например, с помощью фильтра).
- управление транзакциями можно вынести в отдельный фильтр
- неоднородность в названиях методов: метод поиска игрока называется `find*` (findPlayerByName) а метод поиска
  матча `get*` (getMatchesForId)
- методы сохранения сущностей в БД будет логичным переименовать в save и убрать из них название сущности:
  `createPlayer` -> `save(Player player)`
  `createMatch` -> `save(Match match)`
- в методах этого пакета очень много повторяющегося кода — стоит подумать, как избавиться от этого (один из вариантов
  был оговорен в первых двух пунктах)
- для SELECT запроса (все методы, кроме методов сохранения сущностей) можно не использовать
  транзакцию: `em.getTransaction().begin();`
- JPQL запросы можно вынести в константы и дать им понятные имена
- текст запроса удобнее читать, когда ключевые слова написаны в верхнем регистре, а также когда он логично разбит на
  строки:

```sqlite-sql
SELECT p 
FROM Player p 
WHERE p.name = :name
```

- в JPQL ключевое слово `SELECT` можно опускать, если нужно выбрать всю сущность. Но в рамках проекта надо выбрать
  подход и придерживаться его во всех классах — пишем везде или нигде.
  Сейчас в `PlayerDao.findPlayerByName()` так:

```sqlite-sql
select p from Player p where p.name=:name
```

а в `MatchDao.getMatchesForId()` так:

```sqlite-sql
FROM Match m WHERE m.player1.id = :id OR m.player2.id = :id 
```

- ❗️EntityManager реализует интерфейс AutoCloseable, поэтому его можно создавать в try-with-resources блоке. И лучше
  делать именно так, чтобы не заботиться о закрытии вручную и сократить код.
- ❗️проблема N+1 в запросах к БД, что излишне нагружает БД и снижает производительность при больших объёмах данных 

### PlayerDao

- ❗️cмешение слоёв — DAO работает с DTO: `Player findPlayerByName(PlayerNameDto player1)`. В данном случае можно
  передавать `String playerName`
- название метода `findPlayerByName` можно сократить до `findByName` без потери ясности
- в имени параметра `PlayerNameDto player1` не нужна цифра
- ❗️метод `Player findPlayerByName(PlayerNameDto player1)` может вернуть null. Лучше этого избежать и возвращать Optional
- ❗️в методе `Player findPlayerByName(PlayerNameDto player1)` теряется сообщение из NoResultException:

```java
catch(NoResultException e){
    if(em.getTransaction().isActive()){
        em.getTransaction().rollback();
    }
    return null;
}
```

- необъяснимо разные имена одинаковых параметров в методах `Player findPlayerByName(PlayerNameDto player1)`
  и `void createPlayer(PlayerNameDto playerDto)`
- неправильное сообщение об ошибке: `throw new DaoException("match creation error");`
  вместо `throw new DaoException("player creation error");` (строка 50)
- избыточный запрос к БД: `System.out.println(findPlayerByName(playerDto) + "player create");` (cтрока 45)

### MatchDao

- несогласованное управление EntityManager: в `createMatch()` — try-with-resources, в других методах - ручное закрытие в
  finally
- ❗️в методе `getMatchesForId()` не закрывается EntityManager — он не объявлен в try-with-resources, а также нет блока
  finally. Это потенциальная утечка ресурсов.
- Проблемы с именованием методов:
- опечатка в имени параметра метода `createMatch(Match mathForSave)` `mathForSave` -> `matchForSave`, а лучше
  просто `match`
- глагол create обычно используется при создании новых объектов, но здесь передается готовый объект, поэтому
  лучше `saveMatch(Match match)` или `persistMatch(Match match)` или просто `save(Match match)`
- название метода `List<Match> getMatchesForId(int id)` звучит как "получить матчи для Id". Не понятно, о каком Id
  речь — матча или игрока. Лучше, чтобы название метода сообщало, что он делает, например
  так: `findByPlayerId(int playerId)`
- ❗️результат метода `List<Match> getAllMatches()` используется, только чтобы подсчитать общее количество матчей,
  хранящихся в БД. Вытаскивать для этого все матчи из БД избыточно — это нагружает линию коммуникации с БД и расходует
  память. Правильный подход — написать соответствующий запрос в БД (`COUNT(m)`), который вернёт число.
- метод в DAO не должен вычислять смещение: `query.setFirstResult((page - 1) * pageSize);` в
  методе `List<Match> getAllMatchesPagination(int page, int pageSize)`. Логика, будет чище, если он будет принимать уже
  готовые значения и просто подставлять их в запрос (+ сразу переименуем метод):

```java
List<Match> findAllPaginated(int offset,int limit){
    ...
    List<Match> matches=em.createQuery(FIND_ALL_JPQL,Match.class)
            .setFirstResult(offset)
            .setMaxResults(limit)
            .getResultList();
    ...
}
```

- ❗️в этом классе не хватает метода, который возвращает список матчей с пагинацией и отфильтрованных по имени игрока —
  этот функционал не доработан в проекте

### DaoException

- было бы удобно, если бы все классы исключений лежали в одном пакете `exception`
- нет причин оставлять в классе неиспользуемый конструктор

## Service

- ❗️сервисный слой должен преобразовывать DTO в Entity и наоборот. И не должен прокидывать DTO в DAO.
- ❗️жёсткая связь через new ограничивает гибкость и тестируемость кода. Внедрение зависимостей, например через
  конструктор — это способ устранить эти недостатки.
- ❗️все поля во всех сервисах без явного модификатора доступа
- ❗️объекты DAO и других сервисов создаются внутри класса, в месте объявления. Это делает невозможным подмену реализации и
  нарушает принцип открытости/закрытости (Open/Closed Principle) — класс должен быть открыт для расширения, но закрыт
  для изменений. Также такие сервисы невозможно протестировать в отрыве от БД.
  Вместо того чтобы сервис зависел от конкретной реализации DAO, он должен зависеть от абстракции (интерфейса). Тогда мы
  можем легко подменять реализацию, не меняя код сервиса.
  Объекты сервисов могут быть синглтонами или просто создаваться один раз на старте приложения и помещаться, к примеру,
  в контекст. А в нужном месте их можно получать вместо того, чтобы каждый раз создавать заново.
- ❗️создание зависимостей внутри сервиса является нарушением принципа единственной ответственности (Single
  Responsibility). Сервисы должны выполнять бизнес-логику, а созданием зависимостей заниматься кто-то другой.
- логику преобразования Entity -> DTO и DTO -> Entity следует вынести в мапперы.

### PlayerService

- ❗️Race condition при создании игрока — сначала проверяем, существует ли игрок и, если его нет, делаем ещё один запрос,
  чтобы сохранить:

```java
if(playerDao.findPlayerByName(player)==null){
    playerDao.createPlayer(player);
}
```

Между проверкой и сохранением игрока другой поток может создать игрока с тем же именем. И тогда при сохранении возникнет
исключение, которе нигде не обрабатывается и ExceptionFilter вернёт страницу с кодом 500. Хотя создать матч с уже
существующим в БД игроком — нормальная ситуация.
Вместо этого надо сразу пытаться сохранить игрока, позволить БД выбросить ошибку, если такой игрок уже существует и
тогда уже обработать этот случай, продолжив работу приложения.

### MatchService

- поле `PlayerScoreDtoManager manager` никогда не используется в классе
- ❗️в методе `void saveMatch(MatchBoardDto matchBoardDto)` в качестве победителя в БД всегда сохраняется второй игрок:

```java
Player winner=playerForMatch2;
matchForSave.setWinner(winner);
```

- вычисление смещения для корректного отображения матчей на странице должно происходить в
  методе `List<MatchListDto> getAllMatchPagination(int page, int pageSize)`
- ❗️метод `int getTotalMatchCount()` должен получать количество матчей из DAO, вместо получения вообще всех матчей (писал
  об этом выше)

### MatchScoreService

- переменная выполняющая роль флага `int tiebreak` должна быть типа boolean
- ❗️хранение состояния матча в поле сервиса может привести к Race condition и смешиванию состояний разных матчей
- очень запутанная логика подсчёта очков с цепочками if-ов до 4-х уровней вложенности. В ней сложно разобраться и почти
  невозможно хорошо протестировать.
- ❗️помимо сложности, код работает неправильно (описал в разделе **Функциональные ошибки**)
- для реализации логики подсчёта очков хорошо подходит декомпозиция реальной игры или использование паттерна Цепочка
  обязанностей (Chain of responsibility)
- ❗️в методе `MatchBoardDto changeScore(String playerButton, MatchBoardDto matchBoardDto)` зачем-то создаётся экземпляр
  самого MatchScoreService

```java
MatchScoreService matchScoreService=new MatchScoreService();
```

И дальше в `changeScore()` методы класса MatchScoreService используются через этот экземпляр

- много "магических" чисел и строк
- ❗️есть нарушение принципа наименьшего удивления. Например, метод `selectPlayerToChangeScore()` изменяет переданный
  объект, возвращает ссылку на измененный объект, имеет скрытые побочные эффекты.
  Ожидание: Метод должен только выбирать/возвращать данные
  Реальность: Метод изменяет состояние

<details>
<summary><b>Принцип наименьшего удивления</b></summary>
Система должна вести себя так, как ожидает пользователь, и не должна вызывать удивление или замешательство.

В контексте программирования это означает, что:

    - Имена методов и классов должны точно отражать их поведение.
    - Поведение методов должно быть интуитивно понятным и соответствовать тому, что подразумевает их имя.
    - Если метод называется getSomething, он должен возвращать что-то, а не изменять состояние.
    - Если метод называется calculateSomething, он должен вычислять и возвращать результат, а не изменять переданные параметры.

</details>

- ❗️есть побочные эффекты. Например, метод `boardCalculator()` помимо прочего сохраняет матч в БД. Побочные эффекты делают
  код непредсказуемым и сложным для отладки.
- В классе есть много других мелких ошибок. Довести его рефакторингом до пригодного состояния сложно или вообще
  невозможно. Стоит сделать выводы и написать заново логику подсчёта очков.

### TiebreakService

- метод `tiebreak()` изменяет переданный объект player и затем возвращает тот же объект через ссылку temp. Это нарушает
  принцип отсутствия побочных эффектов и может привести к непредсказуемому поведению.
- избыточное создание нового объекта PlayerScoreDto в методе `changeTiebreakScore()`
  Такой блок кода:

```java
PlayerScoreDto temp=new PlayerScoreDto();
if(playerWinsPoint.equals("player1")){
    temp=tiebreak(player1);
}else if(playerWinsPoint.equals("player2")){
    temp=tiebreak(player2);
}
return temp;
```

можно заменить на:

```java
if(playerWinsPoint.equals("player1")){
    return tiebreak(player1);
}
return tiebreak(player2);
```

- ❗️класс не отображает логику тай-брейка
- использование строк "player1" и "player2" подвержено ошибкам. Лучше использовать константы или перечисления.
- ❗️классы подсчёта очков требуют полного переписывания с правильной архитектурой и полной реализацией правил

### MatchesException

- как и другие исключения лучше поместить в пакет `exception`
- и тоже удалить неиспользуемый конструктор
- у этого исключения малоинформативное имя. Представь, если бы NumberFormatException называлось бы NumberException —
  оставалось бы только догадываться, что это может означать.

## Util

### ❗️HibernateListener

- отсутствует реализация метода contextDestroyed() из ServletContextListener, в котором должна закрываться
  EntityManagerFactory и другие ресурсы. Это приводит к "висящим" соединениям с БД при остановке приложения.
- EntityManagerFactory хранится локально в методе `contextInitialized()` — это делает её недоступной для закрытия в
  методе `contextDestroyed()`
- нет обработки исключений при инициализации, что может привести к запуску приложения с неработающей БД

### JPAUtil

- опечатка в имени метода: `getEntutyManager()` -> `getEntityManager()`
- метод `close()` нигде не используется
- в метод `close()` можно добавить проверку, открыта ли
  EntityManagerFactory: `if (emf != null)` -> `if (emf != null && emf.isOpen())`
- в метод `initialize()` можно добавить вызов метода close(), чтобы не допустить повторной инициализации. Другой вариант
  бросить исключение, если emf уже инициализирована. В данном приложении повторной инициализации не предвидится, но это
  будет соответствовать внимательному подходу к ресурсам.
- в методе `getEntityManager()` может возникнуть NullPointerException: в строке `return emf.createEntityManager();` emf
  может быть null
- нет синхронизации при доступе к emf. Если один поток закрывает EMF (через метод close), а другой поток в это время
  пытается получить EntityManager, то возможно получение EntityManager из уже закрытой EntityManagerFactory, что
  приведет к исключению. Такого не произойдёт, потому что EntityManagerFactory нигде и никогда не закрывается, и даже
  после исправления будет закрыта один раз при остановке приложения, но можно от этого защититься.

### ❗️PlayerScoreDtoManager

- данная реализация паттерна singleton не является потокобезопасной. Исправить это можно, добавив ключевое слово
  synchronized к объявлению метода `getInstance()`
- хранилище матчей также не является потокобезопасной структурой данных. Корректно будет использовать ConcurrentHashMap
- метод `setPlayerScoreDto()` создаёт PlayerScoreDto, настраивает их, создаёт MatchBoardDto, настраивает его, сохраняет
  в хранилище, чем нарушает принцип единственной ответственности. Также метод (а следовательно и сам класс) знает
  слишком много о внутренней структуре DTO и их взаимосвязях.
- метод `deleteCurrentMatch()` принимает String, но у Map, из которой он хочет удалить данные, ключом является UUID,
  поэтому удаление никогда не сработает. Также вызов `System.out.println(matchCollection.get("delete" + key))` не имеет
  смысла: конкатенация строки с UUID даст строку, по которой из Map всегда вернётся null, что и будет выведено в
  консоль.
- метод `deleteCurrentMatch()` никогда и нигде не вызывается, что избавляет от последствий его неправильной реализации
- метод `playersSetGamesAndPoints0()` не должен быть в этом классе, поскольку он не имеет отношения к управлению
  матчами — это логика сброса счета.

## Servlet

- ❗️после перемещения jsp файлов в папку WEB-INF нужно будет поправить все пути к этим страницам в местах, где происходит
  forward
`resp.sendRedirect("/match-score?uuid=" + uuid.toString());` — абсолютный путь без контекста приложения -> 
`resp.sendRedirect(req.getContextPath() + "/match-score?uuid=" + uuid);` (`toString()` у uuid можно не вызывать явно) —
относительный путь для редиректа
- ❗️сервлетам присущи все проблемы, связанные с отсутствием модификаторов доступа у полей классов, а также отсутствием
  внедрения зависимостей

### MatchServlet

- ❗️Нарушение принципа единственной ответственности. Сервлет занимается: валидацией входных данных, бизнес-логикой
  создания игроков, работой с менеджером матчей
- где-то сообщение об ошибке написано на английском: `req.setAttribute("errorMessage", "name is too long")`, а где-то
  транслитом: `req.setAttribute("errorMessage", "odinakovoe imya")`
- ❗️неэффективная работа с базой данных:
  В блоке else делается запрос к базе данных, чтобы получить имя игрока, хотя имя уже известно

```java
if(playerService.findPlayerByName(p1)==null){
    playerService.createPlayer(p1);
    System.out.println("player1 save");
}else{
    p1.setName(playerService.findPlayerByName(p1).getName());
    System.out.println("### player "+p1+" already exists ###");
}
```

в строке `p1.setName(playerService.findPlayerByName(p1).getName())` ищется игрок по имени, чтобы получить его имя

- ❗️после forward-ов в блоке:

```java
}else{
    if(playerOne.equals(playerTwo)){
        ...
        req.getRequestDispatcher("/new-match.jsp").forward(req,resp);
    }else if(playerOne.length()>20||playerTwo.length()>20){
        ...
        req.getRequestDispatcher("/new-match.jsp").forward(req,resp);
    }
}
```

надо добавить return, потому что иначе выполнение метода `doPost()` продолжается, что приводит к созданию матча даже при
ошибке валидации.

- здесь нет проверки на null и пустые строки:

```java
String playerOne=req.getParameter("playerOne");
String playerTwo=req.getParameter("playerTwo");
```

- валидацих входных данных следует вынести в классы валидаторов. В зависимостях проекта
  есть `implementation('org.hibernate.validator:hibernate-validator:8.0.1.Final')`, который отлично подходит для этого

### ❗️MatchScoreServlet

- в классе есть два поля PlayerScoreDtoManager — каждому методу по PlayerScoreDtoManager — это избыточно
- Нарушение принципа единственной ответственности. Сервлет занимается: обработкой запросов, изменением счета, проверкой
  окончания матча, сохранением матча
- неправильное управление состоянием матча (которого вообще не должно быть в этом классе): состояние tiebreak хранится в
  MatchScoreService и при каждом запросе создается новый MatchScoreService, теряя состояние тайбрейка
- после того, как игрок выиграл ему ещё добавляются очки:

```java
if(player1Win){
    matchScoreService.selectPlayerToChangeScore(playerButton,matchBoardDto);
    ...
}
```

- флаг завершения матча устанавливается `matchBoardDto.setFinish(true)`, но матч не удаляется из хранилища и может быть
  изменен снова. Также это способствует утечке памяти
- сервлет знает слишком много о бизнес-логике

### MatchesServlet

- ❗️сейчас при фильтрации матчей по имени игрока нет пагинации и сервлет отдаёт все подходящие матчи из БД в любом
  количестве. Пагинация нужна для любого запроса. Для этой цели также надо будет изменить логику подсчёта количества
  матчей: без фильтра считаем все, с фильтром — только подходящие
- общий для обоих условий код надо выносить за пределы if-else
- ❗️Неправильная обработка исключений: любое исключения, возникшее в блоке try оборачивается в PaginationException
- из объявления метода `doGet()` надо удалить исключения, которые он не выбрасывает
- начальные параметры для пагинации не нужно создавать в методе, стоит вынести их в константы. А также они не должны
  быть в сервлете.

### PaginationException

- всё, что сказано выше про другие исключения, относится и к этому
- опечатка `super((ex));` -> `super(ex);`

## Test
### MatchScoreServiceTest
- ❗️в классе всего три теста, которые не покрывают достаточное количество ситуаций, чтобы быть уверенным в том, что подсчёт очков происходит корректно

## persistence.xml

- ❗️учётные данные

```xml
<property name="jakarta.persistence.jdbc.user" value="sa"/>
<property name="jakarta.persistence.jdbc.password" value=""/>
```

не должны попадать в github

## build.gradle
- в текущей реализации эти зависимости не используются:
```groovy
implementation('org.glassfish.jaxb:jaxb-runtime:4.0.5')
implementation('org.hibernate.validator:hibernate-validator:8.0.1.Final')
implementation("org.postgresql:postgresql:42.7.3")
implementation("org.mapstruct:mapstruct:1.6.3")
testCompileOnly("org.projectlombok:lombok:1.18.42")
testAnnotationProcessor("org.projectlombok:lombok:1.18.42")
```

## В целом по проекту

- комментарии лучше удалять для чистоты и чтобы не создавать возможностей запутаться
- многие классы не отформатированы. Перед `git commit` можно нажимать (`cmd + alt + l` в Idea на mac os)
- неиспользуемые импорты в классах. Перед `git commit` можно нажимать (`ctrl + alt + o` в Idea на mac os)
- во многих классах есть лишних отступы: пустые строки (например, перед закрывающей скобкой метода), которые не улучшают
  читаемость кода и создают небольшую визуальную неряшливость
- Цифры в именах переменных. Переменные с именами `player1Win` и `player2Win` проще перепутать при использовании и
  чтении, чем, например, `firstPlayerWin` и `secondPlayerWin`. Вторая причина не использовать цифры в именах
  переменных (особенно парных) в том, что при начале ввода в Idea имени в первом случае (`player1Win` и `player2Win`)
  она не всегда предложит нужное дополнение (чтобы просто нажать Enter после начала ввода), а в другом
  случае (`firstPlayerWin` и `secondPlayerWin`) префиксы имён переменных отличаются явно — это немного ускоряет
  написание кода.
- ❗️Имена переменных и названия методов. Этому можно посвятить отдельное ревью.
  Они не только вводят в заблуждение, но и не отличаются однородностью. Встречаются:

```java
PlayerScoreDto playerScoreDto1;
String playerOneName;
Player player1;
Player playerForMatch1
String playerOne
PlayerScoreDto player1
```

Во всём проекте понятности имён следует уделить большое внимание. Следует называть методы так, чтобы другой разработчик
мог догадаться, что они делают, не заглядывая в реализацию.

- Если решил добавить логирование, то нужно использовать логгер, а не `System.out.println();`. Если отладочные выводы в
  консоль лучше удалять из кода перед финальным коммитом класса.
- ❗️во всём проекте нет ни одного интерфейса, что делает повсеместным нарушение принципа инверсии зависимостей (Dependency
  Inversion) в сервлетах и сервисах
- в блоках catch теряется StackTrace оригинальных сообщений об ошибках и текущие сообщения оказываются не очень
  информативными
- ❗️отсутствуют модификаторы доступа в полях классов

## Другое

- если ввести невалидное имя на странице создания нового матча, то введённые имена не сохраняются — их нельзя исправить
  и нужно вводить заново
- судя по коду, то же было бы при фильтрации завершённых матчей во время перехода на следующую страницу, если бы там
  была пагинация
- папка `.idea` не нужна в репозитории github

## Может быть полезным

- Узнать про record в Java
- Посмотреть, что такое Проблема N+1 в запросах к БД
- Посмотреть, что такое MapStruct
- Посмотреть, что такое Hibernate Validator
- Посмотреть, что такое HikariCP
- Повторить и разобрать на примерах принципы ООП
- Повторить и разобрать на примерах принципы SOLID (для начала SRP)
- Почитать главы, которые привлекут внимание из Чистого кода Роберта Мартина
- Для удобного запуска из Idea CE можно настроить плагины Smart Tomcat или Jetty (для Maven проекта)/Gretty (для Gradle)

## Плюсы
- разделение на слои (Servlet -> Service -> DAO) — верный архитектурный подход
- использование DTO для передачи данных между слоями — хорошая практика
- отдельная страница для отображения победителя
- использование фильтра для обработки исключений
- работает пагинация списка матчей там, где она есть
- есть фильтрация матчей по имени игрока
- использование Lombok для уменьшения boilerplate-кода
- наличие тестов (пусть и минимальных) — хорошее начало
- логирование процесса работы (хоть и через System.out)
- паттерн Singleton для менеджера матчей — идея верная
- попытка инкапсуляции логики тай-брейка в отдельный класс
- логичное разделение классов, а также других файлов проекта по пакетам

## Заключение

Дойти до 4-го проекта с таким уровнем кода — своего рода подвиг. Но по мере усложнения проектов совершать его будет всё сложнее.
Вместе с тем доработка всех (или хотя бы критических) недочётов этого проекта может стать отличной учебной базой.
И, если последуешь рекомендациям, это кардинально улучшит качество кода и углубит твоё понимание разработки на Java.
Несмотря на то, что замечаний большое количество, многие из них проходят через весь проект, а значит, чтобы исправить их, будет достаточно изучить всего одну небольшую тему.
